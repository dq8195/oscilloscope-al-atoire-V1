<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Oscillo SVG — Aléatoire (quiz) + Tracer (sans quiz)</title>
<style>
  :root { --w: 500px; --h: 500px; --uiw: 520px; }
  body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background:#f6f7fb; color:#111; }
  #export-area { border:1px solid #333; background:#fff; padding:10px; width:max(calc(var(--uiw) + 20px),620px); margin:16px auto; box-shadow:0 6px 18px rgba(0,0,0,.08); position: relative; }
  #scope-container { border:2px solid #333; margin-bottom:10px; background:#fff; position: relative; }
  #scope { width: var(--w); height: 528px; display:block; }
  button { padding:8px 10px; border:1px solid #444; background:#fafafa; cursor:pointer; border-radius:6px; }
  button:hover { background:#f0f0f0; }
  button:disabled { opacity: .5; cursor: not-allowed; }
  fieldset { border:1px solid #666; padding:10px; border-radius:8px; }
  legend { font-weight:700 }
  .row { display:flex; gap:10px; flex-wrap:wrap; align-items: center; }
  .input-group { display:flex; align-items:center; gap:6px; margin:6px 0; }
  input[type="number"] { width:120px; padding:4px 6px; }
  select { padding:4px 6px; }
  #extra-zone { width: var(--uiw); }
  .muted { opacity:.75; font-size:.9em }
  /* Quiz */
  #quiz-modal {
    position: fixed; right: 16px; bottom: 16px; z-index: 1000;
    width: min(420px, 90vw);
    background: #ffffff; border: 1px solid #99a; border-radius: 12px;
    box-shadow: 0 12px 28px rgba(0,0,0,.18); padding: 12px; display: none;
  }
  #quiz-modal h3 { margin: 0 0 8px 0; }
  #quiz-modal .qrow { display:flex; gap:8px; align-items:center; margin:6px 0; }
  #quiz-modal .qrow label { width: 170px; }
  #quiz-result { margin-top:8px; padding:8px; background:#f9fafc; border:1px solid #ccd; border-radius:8px; display:none; white-space:pre-wrap; max-height: 200px; overflow:auto; }
  #quiz-actions { margin-top:10px; display:flex; gap:8px; }
  .ok { color:#0a0; font-weight:600; }
  .err { color:#a00; font-weight:600; }
</style>
</head>
<body>

<div id="export-area">
  <div id="scope-container">
    <svg id="scope" viewBox="0 0 500 528" xmlns="http://www.w3.org/2000/svg" aria-label="Écran d'oscilloscope"></svg>
  </div>

  <div class="row">
    <button id="toggle-zone">Afficher / Cacher paramètres</button>
    <button id="export-btn">Enregistrer PNG</button>
    <button id="reset-btn">Réinitialiser</button>

    <button id="rand-once">Aléatoire (quiz)</button>
    <button id="apply-btn" title="Tracer selon les paramètres ci-dessous sans questionnaire">Tracer (sans quiz)</button>
  </div>

  <div id="extra-zone" style="display:none; margin-top:10px;">
    <fieldset>
      <legend>Paramètres signal</legend>
      <div class="row">
        <div class="input-group">
          <label for="signal-type">Type:</label>
          <select id="signal-type">
            <option value="0">Sinus</option>
            <option value="1">Carré (50%)</option>
            <option value="2">Triangle</option>
            <option value="3">Dent de scie</option>
            <option value="4">Rectangulaire (duty %)</option>
            <option value="5">Demi-redressé</option>
            <option value="6">Double-redressé</option>
          </select>
        </div>
        <div class="input-group">
          <label for="amplitude">Amplitude:</label>
          <input type="number" id="amplitude" step="1" value="1" inputmode="decimal">
        </div>
        <div class="input-group">
          <label for="signal-frequency-value">Fréquence (Hz):</label>
          <input type="number" id="signal-frequency-value" step="1" value="50" min="10" max="60" inputmode="numeric" pattern="[0-9]*">
          <select id="signal-frequency-unit" disabled>
            <option value="1" selected>Hz</option>
          </select>
        </div>
        <div class="input-group" id="duty-wrap" style="display:none;">
          <label for="duty">Duty %:</label>
          <input type="number" id="duty" step="1" value="75" min="1" max="99" inputmode="numeric" pattern="[0-9]*">
        </div>
        <div class="input-group">
          <label for="phase">Phase (°):</label>
          <input type="number" id="phase" step="1" value="0" min="-360" max="360" inputmode="decimal">
        </div>
        <div class="input-group">
          <label for="offset">Offset:</label>
          <input type="number" id="offset" step="1" value="0" min="-100" max="100" inputmode="decimal">
        </div>
      </div>
    </fieldset>

    <fieldset>
      <legend>Paramètres oscillo</legend>
      <div class="row">
        <div class="input-group">
          <label for="scope-scale-volt">Volt/div:</label>
          <input type="number" id="scope-scale-volt" step="1" value="1" inputmode="numeric" pattern="[0-9]*">
        </div>
        <div class="input-group">
          <label for="scope-scale-freq-value">Temps/div (ms):</label>
          <input type="number" id="scope-scale-freq-value" step="1" value="20" inputmode="numeric" pattern="[0-9]*">
        </div>
        <div class="input-group">
          <label for="hpos">Pos. horizontale:</label>
          <input type="number" id="hpos" step="1" value="0" inputmode="decimal">
        </div>
      </div>
      <div class="muted">
        f 10–60 Hz • 5 graduations/div • Aléatoire: V/T-div ∈ {1,5,10,15,20} • phase/offset/hpos conservés • amplitude ≤ V/div×5 − |offset|
      </div>
    </fieldset>
  </div>
</div>

<!-- QUIZ MODAL -->
<div id="quiz-modal" role="dialog" aria-label="Quiz signal">
  <h3>Quiz (analyse du signal affiché)</h3>
  <div class="qrow"><label for="q-umax">Umax (V) :</label><input type="number" id="q-umax" step="0.01"></div>
  <div class="qrow"><label for="q-ueff">Ueff (V) :</label><input type="number" id="q-ueff" step="0.01"></div>
  <div class="qrow"><label for="q-amp">Amplitude (V) :</label><input type="number" id="q-amp" step="0.01"></div>
  <div class="qrow"><label for="q-freq">Fréquence (Hz) :</label><input type="number" id="q-freq" step="0.01"></div>
  <div id="quiz-result"></div>
  <div id="quiz-actions">
    <button id="quiz-submit">Valider</button>
    <button id="quiz-close">Fermer</button>
  </div>
  <div class="muted" style="margin-top:6px;">Tolérance ±2% (ou ±0.02 autour de 0).</div>
</div>

<script>
/* ---------- Constantes & groupes ---------- */
const svg=document.getElementById('scope');const NS=svg.namespaceURI;
const W=500,H=500,FOOTER_H=28;const rows=10,cols=10;
const cellW=W/cols,cellH=H/rows;

const gGrid=newEl('g'),gWave=newEl('g'),gUI=newEl('g');
svg.appendChild(gGrid);svg.appendChild(gWave);svg.appendChild(gUI);
const txtVolt=newEl('text',{x:10,y:H+FOOTER_H-6,'font-size':14,fill:'#000'});
const txtTime=newEl('text',{x:300,y:H+FOOTER_H-6,'font-size':14,fill:'#000'});
gUI.appendChild(txtVolt);gUI.appendChild(txtTime);

/* ---------- État ---------- */
let state={signalType:0,amplitude:1,fVal:50,fUnit:1,offsetV:0,duty:75,phaseDeg:0,vDiv:1,tDivVal:20,tDivUnit:2,hpos:0};

/* ---------- Utils ---------- */
function newEl(tag,attrs={}){const el=document.createElementNS(NS,tag);for(const[k,v]of Object.entries(attrs))el.setAttribute(k,v);return el;}
function clamp(v,lo,hi){return Math.min(hi,Math.max(lo,v));}
function hz(){return clamp(Math.round(state.fVal)||10,10,60);} // Hz 10–60
function secondsPerDiv(){return state.tDivVal*1e-3;} // ms
function pxPerVolt(){return (H/rows)/state.vDiv;}
function randInt(min,max){return Math.floor(Math.random()*(max-min+1))+min;}
function fmt(n,dec=2){return (+n).toFixed(dec);}
const allowedScale=[1,5,10,15,20];

/* ---------- Grille + 5 graduations/div ---------- */
function drawGrid(){
  gGrid.replaceChildren();
  gGrid.appendChild(newEl('rect',{x:0,y:0,width:W,height:H,fill:'none',stroke:'#333','stroke-width':2}));
  const gridPath=[];
  for(let i=0;i<=cols;i++) gridPath.push(`M${i*cellW},0 V${H}`);
  for(let j=0;j<=rows;j++) gridPath.push(`M0,${j*cellH} H${W}`);
  gGrid.appendChild(newEl('path',{d:gridPath.join(' '),stroke:'#888','stroke-width':1,fill:'none'}));
  gGrid.appendChild(newEl('line',{x1:0,y1:H/2,x2:W,y2:H/2,stroke:'#666','stroke-width':2}));
  gGrid.appendChild(newEl('line',{x1:W/2,y1:0,x2:W/2,y2:H,stroke:'#666','stroke-width':2}));
  const tickLen=5, minor=[];
  for(let i=0;i<=cols*5;i++){const x=i*(cellW/5); minor.push(`M${x},${H/2 - tickLen} V${H/2 + tickLen}`);}
  for(let j=0;j<=rows*5;j++){const y=j*(cellH/5); minor.push(`M${W/2 - tickLen},${y} H${W/2 + tickLen}`);}
  gGrid.appendChild(newEl('path',{d:minor.join(' '),stroke:'#aaa','stroke-width':1,fill:'none'}));
}

/* ---------- Signal ---------- */
function drawSignal(){
  gWave.replaceChildren();
  const f=hz(),tDiv=secondsPerDiv(),totalTime=tDiv*cols,samples=W,amp=state.amplitude,yScale=pxPerVolt(),phase0=state.phaseDeg*Math.PI/180;
  const y0=H/2-state.offsetV*yScale;
  gWave.appendChild(newEl('polygon',{points:`0,${y0} 12,${y0-10} 12,${y0+10}`,fill:'red'}));
  const label=newEl('text',{x:16,y:y0+5,'font-size':12,fill:'red'});label.textContent='Offset';gWave.appendChild(label);

  let d='';
  for(let x=0;x<samples;x++){
    const t=((x-state.hpos)/W)*totalTime,ph=2*Math.PI*f*t+phase0;
    let yv;
    switch(state.signalType){
      case 1: yv=Math.sign(Math.sin(ph))||1; break;                       // carré 50%
      case 2: { const u=((ph/(2*Math.PI))%1+1)%1; yv=2*Math.abs(2*u-1)-1; break; } // triangle
      case 3: { const u=((ph/(2*Math.PI))%1+1)%1; yv=2*u-1; break; }      // dent de scie
      case 4: { const duty=clamp(state.duty,1,99)/100; const u=((ph/(2*Math.PI))%1+1)%1; yv=(u<duty)?1:-1; break;} // rect %
      case 5: yv=Math.max(0,Math.sin(ph)); break;                         // demi-redressé
      case 6: yv=Math.abs(Math.sin(ph)); break;                           // double-redressé
      default: yv=Math.sin(ph);                                           // sinus
    }
    const v=yv*amp+state.offsetV;
    const y=H/2 - v*yScale;
    d+=(x?' L':'M')+x+','+y.toFixed(2);
  }
  gWave.appendChild(newEl('path',{d,stroke:'lime','stroke-width':2,fill:'none'}));
}

/* ---------- Labels & rendu ---------- */
function updateLabels(){ txtVolt.textContent=state.vDiv+' V/div'; txtTime.textContent=state.tDivVal+' ms/div'; }
function render(){ drawGrid(); drawSignal(); updateLabels(); }

/* ---------- T/div cohérent avec f ---------- */
function chooseCoherentTdivMsFromF(fHz){
  const k = (Math.random()<0.5)?2:4; // ~2 ou ~4 périodes visibles
  const tDivMsTarget = (k*1000)/(fHz*10);
  let best=allowedScale[0], bestErr=Infinity;
  for (const v of allowedScale){ const err=Math.abs(v - tDivMsTarget); if (err<bestErr){best=v;bestErr=err;} }
  return best;
}

/* ---------- RMS/Mean & réponses ---------- */
function rms_and_mean_for_shape(A,type,D=0.5){
  switch(type){
    case 0: return {rms: A/Math.SQRT2, mean: 0}; // sinus
    case 1: return {rms: A, mean: 0};            // carré ±A
    case 2: return {rms: A/Math.sqrt(3), mean: 0}; // triangle
    case 3: return {rms: A/Math.sqrt(3), mean: 0}; // dent de scie
    case 4: { const mean=A*(2*D-1); return {rms:A, mean}; } // rect ±A duty D
    case 5: return {rms: A/2, mean: A/Math.PI}; // demi-redressé sinus
    case 6: return {rms: A/Math.SQRT2, mean: 2*A/Math.PI}; // double-redressé
    default: return {rms: A/Math.SQRT2, mean: 0};
  }
}
function compute_correct_answers(){
  const A = state.amplitude, f = hz(), V0 = state.offsetV;
  const D = clamp((state.duty||50)/100, 0.01, 0.99);
  const Umax = V0 + A;
  const base = rms_and_mean_for_shape(A, state.signalType, D);
  const Ueff = Math.sqrt( V0*V0 + 2*V0*base.mean + base.rms*base.rms );
  return {Umax, Ueff, Amp:A, f, base, V0, D};
}
function fmtExplain(ans){
  const {base,V0,D,f} = ans; const A = state.amplitude, type = state.signalType;
  const names = ['sinus','carré 50%','triangle','dent de scie','rectangulaire (duty)','demi-redressé','double-redressé'];
  let t = `Type: ${names[type]}, f=${fmt(f,2)} Hz, A=${fmt(A,2)} V, V0=${fmt(V0,2)} V${type===4?`, D=${fmt(D*100,0)}%`:``}\n`;
  t += `Umax = V0 + A = ${fmt(V0,2)} + ${fmt(A,2)} = ${fmt(V0 + A,2)} V\n`;
  const cases = {
    0: `Ueff(signal)=A/√2=${fmt(A,2)}/√2=${fmt(base.rms,2)} V, mean=0`,
    1: `Ueff(signal)=A (carré ±A), mean=0`,
    2: `Ueff(signal)=A/√3=${fmt(A,2)}/√3=${fmt(base.rms,2)} V, mean=0`,
    3: `Ueff(signal)=A/√3=${fmt(A,2)}/√3=${fmt(base.rms,2)} V, mean=0`,
    4: `Rect ±A, duty D: Ueff(signal)=A, mean=A(2D-1)=${fmt(base.mean,2)} V`,
    5: `Demi-redressé: Ueff(signal)=A/2=${fmt(base.rms,2)} V, mean=A/π=${fmt(base.mean,2)} V`,
    6: `Double-redressé: Ueff(signal)=A/√2=${fmt(base.rms,2)} V, mean=2A/π=${fmt(base.mean,2)} V`
  };
  t += (cases[type] || `Ueff(signal)=A/√2, mean=0`) + '\n';
  t += `Ueff(total)=√(V0²+2V0·mean+Ueff(signal)²)=${fmt(Math.sqrt(V0*V0+2*V0*base.mean+base.rms*base.rms),2)} V\n`;
  t += `(Rappel) T=1/f → T=${fmt(1000/f,2)} ms`;
  return t;
}

/* ---------- Quiz (non bloquant) + verrou toggle ---------- */
const modal = document.getElementById('quiz-modal');
const qUmax = document.getElementById('q-umax');
const qUeff = document.getElementById('q-ueff');
const qAmp  = document.getElementById('q-amp');
const qFreq = document.getElementById('q-freq');
const qResult = document.getElementById('quiz-result');
const btnSubmit = document.getElementById('quiz-submit');
const btnClose  = document.getElementById('quiz-close');
const btnToggle = document.getElementById('toggle-zone');
const extraZone = document.getElementById('extra-zone');
let quizPending = false;
let pendingQuiz = null;

function resetQuizUI(){ [qUmax,qUeff,qAmp,qFreq].forEach(i=>i.value=''); qResult.style.display='none'; qResult.textContent=''; }
function openQuiz(){ resetQuizUI(); modal.style.display='block'; quizPending = true; btnToggle.disabled = true; }
function closeQuiz(){ modal.style.display='none'; }

function withinTol(user,correct){
  const tolRel=0.02, tolAbs=0.02; const diff=Math.abs(user-correct);
  return diff <= Math.max(tolAbs, Math.abs(correct)*tolRel);
}
btnSubmit.onclick=()=>{
  if(!pendingQuiz) return;
  const a=pendingQuiz.answers;
  const u={Umax:+qUmax.value, Ueff:+qUeff.value, Amp:+qAmp.value, Freq:+qFreq.value};
  let ok=true, rep=[];
  if(isNaN(u.Umax)||!withinTol(u.Umax,a.Umax)){ok=false;rep.push(`❌ Umax: ${qUmax.value} V → ${fmt(a.Umax,2)} V`);} else rep.push(`✅ Umax OK`);
  if(isNaN(u.Ueff)||!withinTol(u.Ueff,a.Ueff)){ok=false;rep.push(`❌ Ueff: ${qUeff.value} V → ${fmt(a.Ueff,2)} V`);} else rep.push(`✅ Ueff OK`);
  if(isNaN(u.Amp)||!withinTol(u.Amp,a.Amp)){ok=false;rep.push(`❌ Amplitude: ${qAmp.value} V → ${fmt(a.Amp,2)} V`);} else rep.push(`✅ Amplitude OK`);
  if(isNaN(u.Freq)||!withinTol(u.Freq,a.f)){ok=false;rep.push(`❌ Fréquence: ${qFreq.value} Hz → ${fmt(a.f,2)} Hz`);} else rep.push(`✅ Fréquence OK`);

  quizPending=false; btnToggle.disabled=false;

  if(ok){ qResult.style.display='block'; qResult.innerHTML='<span class="ok">Bravo, tout est correct ✔</span>'; setTimeout(()=>closeQuiz(),600); }
  else  { qResult.style.display='block'; qResult.textContent=rep.join('\n')+'\n\nDéveloppement :\n'+fmtExplain(a); }
};
btnClose.onclick=()=>{ if(quizPending){ qResult.style.display='block'; qResult.textContent="⚠️ Réponds d'abord au questionnaire (Valider) pour pouvoir fermer."; return; } closeQuiz(); };

/* ---------- Random cohérent (affiche d'abord, quiz après) ---------- */
function randomizeState(){
  state.signalType = randInt(0,6);
  state.fVal = randInt(10,60);
  state.tDivVal = chooseCoherentTdivMsFromF(state.fVal); state.tDivUnit=2;

  let ampRaw = randInt(1,20), vdivIdx=0;
  function maxPeakAt(i){ return allowedScale[i]*5 - Math.abs(state.offsetV); }
  while(vdivIdx<allowedScale.length-1 && maxPeakAt(vdivIdx)<ampRaw) vdivIdx++;
  state.vDiv = allowedScale[vdivIdx];
  const maxAmp = Math.max(1, Math.floor(maxPeakAt(vdivIdx)));
  state.amplitude = Math.min(ampRaw, maxAmp);

  if(state.signalType===4) state.duty = randInt(5,95);

  applyStateToInputs();

  // (1) cacher paramètres à chaque tirage
  extraZone.style.display='none';

  // (2) tracer immédiatement
  render();

  // (3) quiz
  pendingQuiz = {answers: compute_correct_answers()};
  openQuiz();
}

/* ---------- Tracer manuel (SANS QUIZ) ---------- */
function enforceAmplitudeLimit(){
  const maxA = Math.max(0, state.vDiv*5 - Math.abs(state.offsetV));
  if(state.amplitude>maxA) state.amplitude = Math.max(0, Math.floor(maxA));
}
function applyManual(){
  state.signalType=+document.getElementById('signal-type').value;
  state.amplitude=+document.getElementById('amplitude').value||0;
  state.fVal=+document.getElementById('signal-frequency-value').value||10;
  state.fVal=clamp(Math.round(state.fVal),10,60);
  state.duty=+document.getElementById('duty').value||75;
  state.phaseDeg=+document.getElementById('phase').value||0;
  state.offsetV=+document.getElementById('offset').value||0;
  state.vDiv=+document.getElementById('scope-scale-volt').value||1;
  state.tDivVal=+document.getElementById('scope-scale-freq-value').value||20;
  state.hpos=+document.getElementById('hpos').value||0;

  enforceAmplitudeLimit();
  applyStateToInputs();
  render();

  // déverrouillage + montre les paramètres
  pendingQuiz=null; quizPending=false; btnToggle.disabled=false; closeQuiz();
  document.getElementById('extra-zone').style.display='block';
}

/* ---------- UI ---------- */
const $=id=>document.getElementById(id);
$('toggle-zone').onclick=()=>{ const ez=$('extra-zone'); if($('toggle-zone').disabled) return; ez.style.display=(ez.style.display==='none')?'block':'none'; };
$('reset-btn').onclick=()=>{state={signalType:0,amplitude:1,fVal:50,fUnit:1,offsetV:0,duty:75,phaseDeg:0,vDiv:1,tDivVal:20,tDivUnit:2,hpos:0};applyStateToInputs(); /* pas de rendu auto */ };
$('signal-type').onchange=e=>{state.signalType=+e.target.value;$('duty-wrap').style.display=(state.signalType===4)?'flex':'none';};
$('amplitude').oninput=e=>{state.amplitude=+e.target.value;};
$('signal-frequency-value').addEventListener('keydown',e=>{ if(e.key==='Enter'){ let v=+e.currentTarget.value||10; v=clamp(Math.round(v),10,60); e.currentTarget.value=v; state.fVal=v; }});
$('signal-frequency-value').addEventListener('blur',e=>{ let v=+e.currentTarget.value||10; v=clamp(Math.round(v),10,60); e.currentTarget.value=v; state.fVal=v; });
$('offset').oninput=e=>{state.offsetV=+e.target.value;};
$('duty').oninput=e=>{state.duty=+e.target.value;};
$('phase').oninput=e=>{state.phaseDeg=+e.target.value;};
$('scope-scale-volt').oninput=e=>{state.vDiv=+e.target.value;};
$('scope-scale-freq-value').oninput=e=>{state.tDivVal=+e.target.value;};
$('hpos').oninput=e=>{state.hpos=+e.target.value;};
$('rand-once').onclick=randomizeState;
$('apply-btn').onclick=applyManual;

/* ---------- Export PNG ---------- */
$('export-btn').onclick=()=>{const clone=svg.cloneNode(true);
  const bg=newEl('rect',{x:0,y:0,width:W,height:H+FOOTER_H,fill:'#fff'}); clone.insertBefore(bg,clone.firstChild);
  const svgData=new XMLSerializer().serializeToString(clone);
  const url=URL.createObjectURL(new Blob([svgData],{type:'image/svg+xml;charset=utf-8'}));
  const img=new Image(); img.onload=()=>{const canvas=document.createElement('canvas');canvas.width=W+20;canvas.height=(H+FOOTER_H)+20;const ctx=canvas.getContext('2d');
    ctx.fillStyle='#fff';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.drawImage(img,10,10);URL.revokeObjectURL(url);
    canvas.toBlob(blob=>{const a=document.createElement('a');a.download='oscilloscope.png';a.href=URL.createObjectURL(blob);a.click();});};
  img.src=url;
};

/* ---------- Inputs ⇄ État ---------- */
function applyStateToInputs(){
  $('signal-type').value=state.signalType;
  $('amplitude').value=state.amplitude;
  $('signal-frequency-value').value=state.fVal;
  $('signal-frequency-unit').value=1;
  $('offset').value=state.offsetV;
  $('duty').value=state.duty;
  $('phase').value=state.phaseDeg;
  $('scope-scale-volt').value=state.vDiv;
  $('scope-scale-freq-value').value=state.tDivVal;
  $('hpos').value=state.hpos;
  $('duty-wrap').style.display=(state.signalType===4)?'flex':'none';
}

/* ---------- Start ---------- */
/* IMPORTANT: pas de render() au démarrage → écran vide jusqu'à action utilisateur */
applyStateToInputs();
</script>
</body>
</html>
